"""encoder.py.

Utilities for encoding PCM data into various formats asynchronously.
"""
import math
import asyncio
# Stdlib Soundfile Imports
import wave
import aifc

# Try the soundfile import. If it fails, set a flag, but don't fail;
# the native driver will then only support WAV, AIFF, and similar.
try:
    import soundfile
    _SOUNDFILE_IMPORTED = True

    # For now, let's only permit FLAC and OGG (if supported).
    SOUNDFILE_FORMATS = set(['FLAC', 'OGG']).intersection(
        soundfile.available_formats().keys()
    )
except ImportError:
    # Import failed, so set it false.
    _SOUNDFILE_IMPORTED = False
    SOUNDFILE_FORMATS = set()


_FORMAT_REGISTRY = {
    'WAV': 'audio/wav',
    'AIFF': 'audio/aiff',
    'AIFC': 'audio/aiff',
    'FLAC': 'audio/flac',
    'OGG': 'audio/ogg',
}


class UnsupportedFormatError(Exception):
    """Exception indicating an unsupported format."""


def get_mime_type_for_format(fmt):
    """Return the MIME type for the given format."""
    return _FORMAT_REGISTRY.get(fmt.upper(), 'application/octet-stream')


class RequestFileHandle(object):
    """Wrapper class to give 'web.RequestHandler' a 'file-like' interface.

    This fakes a seekable stream to avoid exceptions when using this with
    python's "wave" and "aifc" modules.
    """

    def __init__(self, handler):
        """Constructor that accepts the RequestHandler to write to."""
        self._handler = handler
        self._count = 0

    def write(self, data):
        """Write the given data to the handler."""
        self._handler.write(data)
        self._count += len(data)

    def close(self):
        """No-op when wrapping some RequestHandler instance."""
        pass

    def tell(self):
        """Return current bytes written.

        The number of bytes written is also the current position in the
        stream, since we do not permit seeking.
        """
        return self._count

    def seek(self, *args):
        """No-op, since this stream is not seekable."""
        pass

    def flush(self):
        pass

    async def async_flush(self):
        await self._handler.flush()


async def encode_from_driver(driver, file_obj, fmt, timeout, async_flush=None):
    """Encode PCM data as generated by the given driver.

    The driver should include the information about the PCM data encoding,
    such as the channel count, sample rate, etc.

    An optional 'async_flush' kwarg is added to permit asynchronously flushing
    on each iteration (if desired). This permits writing out data in real-time
    without buffering concerns (useful when writing to a web.RequestHandler,
    for example).
    """
    # Ignore async_flush if it isn't a coroutine.
    if async_flush and not asyncio.iscoroutinefunction(async_flush):
        async_flush = None
    fmt = fmt.upper()
    # Check the format and decide what to do.
    if fmt in set(['WAV', 'AIFF', 'AIFC']):
        await _process_using_native_library(
            driver, file_obj, fmt, timeout, async_flush=async_flush)
    elif fmt in SOUNDFILE_FORMATS:
        await _process_using_soundfile(
            driver, file_obj, fmt, timeout, async_flush=async_flush)
    else:
        raise UnsupportedFormatError('Unsupported format: {}'.format(fmt))


async def _process_using_native_library(
        driver, file_obj, fmt, timeout, async_flush=None):
    """Write out the PCM data using the native python 3 sound libraries.

    The formats here should always be supported and are comparatively
    simple, but are also generally large/uncompressed.
    """
    # The 'timeout' parameter is the number of seconds. If negative
    # (or None), this implies indefinite. Since we cannot _actually_
    # do that, we set the number of frames to some arbitrarily large
    # number.
    if timeout is not None and timeout > 0:
        frame_count = int(math.ceil(48000 * timeout))
    else:
        # Some arbitrarily large number, mapping to 1000 minutes.
        frame_count = 48000000

    writer = None
    if fmt == 'WAV':
        writer = wave.open(file_obj, 'wb')
        writer.setnchannels(driver.nchannels)
        writer.setsampwidth(driver.sample_width)
        writer.setframerate(driver.framerate)
        writer.setnframes(frame_count)
        writer.setcomptype('NONE', 'No compression.')
    elif fmt == 'AIFF':
        writer = aifc.open(file_obj, 'wb')
        writer.setnchannels(driver.nchannels)
        writer.setsampwidth(driver.sample_width)
        writer.setframerate(driver.framerate)
        writer.setnframes(frame_count)
        writer.setcomptype(b'NONE', b'No compression.')
    elif fmt == 'AIFC':
        writer = aifc.open(file_obj, 'wb')
        writer.setnchannels(driver.nchannels)
        writer.setsampwidth(driver.sample_width)
        writer.setframerate(driver.framerate)
        writer.setnframes(frame_count)
        writer.setcomptype(b'G722', b'G.722 Compression.')
    else:
        raise UnsupportedFormatError(
            'Unsupported format: {}'.format(fmt))

    try:
        # Precalculate the frame size:
        frame_size = driver.sample_width * driver.nchannels
        frame_num = 0
        async for pcm_data in driver.pcm_data_generator():
            # Writing data:
            writer.writeframesraw(pcm_data)

            if async_flush:
                await async_flush()
            frame_num += (len(pcm_data) / frame_size)
            # Stop writing frames if we've exceeded the frame count.
            if frame_num >= frame_count:
                return
    finally:
        if writer:
            writer.close()

async def _process_using_soundfile(
        driver, file_obj, fmt, timeout, async_flush=None):
    """Process the request using 'soundfile'.

    This handles requests using python's "soundfile" import and the
    applicable 'libsndfile' dynamic library, if it is available. This
    supports more formats than just WAV, AIFF, and AU.
    """
    try:
        writer = soundfile.SoundFile(
            file_obj, mode='w', format=fmt.upper(),
            samplerate=driver.framerate, channels=driver.nchannels)
    except Exception:
        raise UnsupportedFormatError('Unsupported format: {}'.format(fmt))

    if timeout is not None and timeout > 0:
        frame_count = int(math.ceil(48000 * timeout))
    else:
        frame_count = None

    # Write out the frame data.
    try:
        # Precalculate the frame size
        frame_size = driver.sample_width * driver.nchannels
        frame_num = 0
        async for pcm_data in driver.pcm_data_generator():
            writer.buffer_write(pcm_data, dtype='int16')
            if async_flush:
                await async_flush()

            # Count the number of frames, like with the native driver.
            # The contents here are likely
            frame_num += (len(pcm_data) / frame_size)
            # Stop writing frames if we've exceeded the frame count.
            if frame_count is not None and frame_num >= frame_count:
                # Explicitly close the writer, then set it None. This
                # tells the soundfile to flush any remaining contents
                # to the stream before we exit the request.
                writer.close()
                writer = None
                return
    finally:
        if writer:
            writer.close()
